👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  createDocumentFragment 살펴보기
- [ ]  offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기
- [ ]  합성 이벤트 시스템의 내부구현 살펴보기

정민

- [x]  빅오 표기법 확인
    - 프론트에서 사용할 떄
- [ ]  문서 조각, 브라우저 호환성 찾아보기
- [x]  getBoundingClientRect 사용 방법 찾아보기
- [x]  레이아웃 스레싱 찾아보기
- [x]  pollyfill과 syntheticEvent 다른점 찾아보기?

### 북스터디 진행 방식

1. 다음주에 이전주의 액션아이템을 실천했다면 경험을 공유해보기, 이야기 나눠보기
2. 문장 혹은 이야기하고 문단까지 읽어보기, 한 페이지씩 읽어보기 (챕터는 유동적으로)
    1. 한 사람 3페이지 읽고 1~2분 타이필 → 다시 읽기
    2. 3~5분 정도 회고 시간 가지기
3. 하은 → 정민 다 읽고 회고 하고 액션아이템 찾아보기

# Chapter 3 가상DOM (p87~p96)

하은

- $$typeof 는 유효한 리액트 엘리먼트인지 확인할 때 사용하는 특수한 심벌
- type 속성은 엘리먼트가 나타내는 컴포넌트 종류, div 와 같은 경우는 string 또는 사용자 정의 컴포넌트인 경우에는 컴포넌트 함수
- 리액트는 엘리먼트 깊숙한 단계로 계속 들어가며 스칼라 값(텍스트)을 만나면 텍스트 노드로 렌더링함
- 스칼라 값: 더 이상 분해되지 않는 단일 값
- ref 속성으로 기본 DOM 노드에 대한 참조를 요청 할 수 있음, DOM 직접 조작하는 경우
- _owner 엘리먼트의 업데이트를 담당할 컴포넌트를 결정하는데 사용됨, 이 정보는 내부적으로 구현을 위해서만 사용함
- _store 엘리먼트에 대한 추가 데이터를 저장하기위해 리액트 내부적으로 사용하는 객체, 직접접근 x
- 리액트 엘리먼트 생성, DOM 노드 생성은 엘리먼트를 생성한다는 점에서만 유사함
- 리액트의 createElement는 메모리에 새로운 “가상”엘리먼트를 생성
- DOM의 createElement는 메모리에 새로운 엘리먼트를 생성
- 리액트 컴포넌트가 렌더링되면 리액트는 새 가상 DOM트리를 생성하고 이전 가상 DOM 트리와 비교한다음 이전 트리와 새트리를 일치하도록 업데이트하는데 필요한 최소 변경횟수를 계산 → 재조정 프로세스
- 리액트 컴포넌트의 상태나 프롭이 변경되면 새로운 엘리먼트 트리를 생성함
- 리액트의 비교알고리즘은 차이점을 식별하고 노드가 변경, 추가, 제거되면 리액트는 실제 DOM해당 노드를 추가및 제거함. 이과정은  재귀적으로 이루어짐. → 변경되는 부분을 알아내는 작업을 디핑이라고 하고, 이를 디핑알고리즘이라고 부름
    - 루트 노드가 다른 경우 기존 트리를 교체
    - 루트 노드가 동일하면, 속성이 변경된 경우에만 업데이트
    - 자식노드가 다르다면 바뀐 자식노드만 업데이트
    - 자식들이 동일하지만 순서가 변경된 경우, 실제 DOM에서 순서를 다시 설정
    - 노드의 종류가 변경된 경우 새 노드를 생성함
    - key 프롭이 있다면 노드의 교체가 필요한지 파악함
- 불필요한 리렌더링
    - 리렌더링은 애초에 리액트가 설계된대로 동작하는 방식
    - 각 함수 컴포넌트를 재귀적으로 호출하면서 프롭을 인수로 각 함수컴포넌트에 전달함
    - 리액트는 컴포넌트가 어느 상태에 종속되는진 알지 못하기 때문에 UI 일관성을 유지하기위해, 모든 컴포넌트를 리렌더링함
    - 대규모 애플리케이션이라면 많은 컴포넌트가 불필요하게 리렌더링 되어 잠재된 성능문제가 발생할 수 있음
    - 상위 컴포넌트의 상태가 프롭이 변경되더라도 하위 컴포넌트에 불필요한 리렌더링이 발생하지 않도록 관리해야함

정민

- $$typeof 객체가 유효한 리액트 엘리먼트인지 확인할 떄 사용하는 특수한 심벌이다.
- type 는 리액트 엘리먼트의 종류를 식별하는 표시자 역할을한다.
- type 속성은 엘리먼트가 나타내는 컴포넌트의 종류를 알려 준다.
    - 스칼라 값을 만나면 이를 텍스트 노들 렌더링한다.
    - null 또는 undefined를 만나면 아무것도 렌더링하지 않는다.
- 부모컴포넌트는 ref를 사용해 기본 DOM 노드에 대한 참조를 요청할 수 있다.
    - 보통 DOM을 직접 조작해야 하는 경우에 사용된다.
- 컴포넌트에 전달 된 모든 속성과 프롭을 포함하는 객체 (props)
- _owner는 프로덕션 빌드가 아닐 때만 접근할 수 있는 속성으로, 이 엘리먼트를 생성한 컴포넌트를 추적하기 위해 리액트에서 내부적으로 사용된다.
    - 프롭이나 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 결정하는 데 사용된다.
    - 리액트가 내부적으로 구현을 위해서만, 애플리케이션 코드에서 사용하면 안된다.
- _store 속성은 엘리먼트에 대한 추가 데이터를 저장하기 위해 리액트가 내부적으로 사용하는 객체 입니다.
    - _store에 저장된 특정 속성 및값은 공개 API의 일부가 아니므로 직접 접근해서는 안된다.
- react.createElement 함수와 DOM에 내장된 document.createElement 메서드는 모두 새로운 엘리먼트를 생성한다는 점에서 유사
    - 하지만 리액트 엘리먼트, DOM노드를 생성하는 것으로 구현방식은 크게 다르지만 개념적으로 비슷하다.
    - 리액트에서 제공하는 create는 메모리에 새로운 가상 엘리먼트를 사용한다.
    - dom은 domAPI에 제공하는 appendChild등의 API로 DOM에 추가 되기전, 메모리에 엘리먼트를 생성한다.
- 재조정 프로세스
- 리액트의 가상 DOM을 사용하면 실제 DOM을 효율적으로 업데이트할 뿐만 아니라 DOM을 직접 조작하는 다른 라이브러리도 원할하게 동작할 수 있다.
- 리액트는 업데이트 된 사용자 인터페이스를 표현하는 새로운 리액트 엘리먼트 트리를 생성한다.
- 비교 알고리듬을 사용해 새 트리를 이전 트리와 비교해 실제 DOM의 업데이트에 필요한 최소한의 변경 사항을 결정한다.
- 둘이 차이점을 식별하는데 이 때 비교 는 재귀적으로 이뤄진다.
- 새 트리와 이전 트리를 노드별로 비교해 트리의 어느 부분이 변경되었는지 알아내는 작업을 디핑이라고 한다.
    - 리액트의 디핑 알고리듬은 고도로 최적화 되었으며 실제 DOM에 적용해야 하는 변경 횟수의 최소화를 목표로 한다.
- 리액트는 컴포넌트가 어느 상태에 종속되는지 알지 못하기 때문에 UI의 일관성을 유지하기 위해 모든 컴포넌트를 리렌더링한다.
- 대규모 애플리케이션이라면 많은 컴포넌트가 불필요하게 리렌더링되어 잠재되었던 성능 문제가 불거질 수 있으므로 최적화를 자주 실행해야 한다.

🥳 좋았던점 또는 알게된점(내용)

하은

- 상위 컴포넌트의 상태가 프롭이 변경되더라도 하위 컴포넌트에 불필요한 리렌더링이 발생하지 않도록 관리해야함
- 디핑 알고리즘이라는 이름이 있는진 몰랐음
- 불필요한 리렌더링에서 공감되는게, 특히나 props가 변경된다면 리렌더링이 일어날텐데, 이를 위해서라도 더더욱 props에 객체를 넘기는 것은 주의깊게 생각해야할 점이라고 보여진다

정민

- $$typeof, type, ref, props, _owner, _store
    - _owner는 많이 못봤어서 좋은 예시 인것 같다.
- 스칼라 값을 만나면 이를 텍스트 노들 렌더링한다.
    - 스칼라에 대한 단어를 알았다.
- 새 트리와 이전 트리를 노드별로 비교해 트리의 어느 부분이 변경되었는지 알아내는 작업을 디핑이라고 한다.
- react.createElement 함수와document.createElement 메서드는 유사

🥲 아쉬운점 또는 의문인점(내용)

하은

- 

정민

- 리액트는 컴포넌트가 어느 상태에 종속되는지 알지 못하기 때문에 UI의 일관성을 유지하기 위해 모든 컴포넌트를 리렌더링한다.
- 대규모 애플리케이션이라면 많은 컴포넌트가 불필요하게 리렌더링되어 잠재되었던 성능 문제가 불거질 수 있으므로 최적화를 자주 실행해야 한다.

👻 액션아이템 - 실천해볼만한 것

하은

- 가상 돔 트리에서 props의 변화를 시각적으로 살펴볼 수 있는 교보재가 잇으면 찾아보기

정민

- _owner, _store 확인해보기
- react.createElement 및 document.element 차이점 확인
- 불필요한 렌더링 찾아보기

# Chapter 3.4 돌아보기 ~ 4. 재조정 (115p~125p)

하은

- 리액트의 함수가 하는 일을 이해해야한다
- 리액트의 가상 DOM은 우리가 원하는 UI 상태의 청사진, 재조정이라는 프로세스를 통해 호스트환경에서 현실로 만듬
- 엘리먼트 트리는 UI 상태의 선언적 설명
- 필요한 DOM API의 호출을 어떻게 최소화 할까?
- 문서 조각은 다수의 DOM 노드를 포함하는 가벼운 컨테이너로, 일종의 임시 스테이징 영역처럼 동작해서 실제 DOM에 영향을 주지않고 여러 변경사항을 반영함
- 비슷한 맥락에서 리액트는 재조정 과정에서 여러 가상 DOM 업데이트를 모아 한번이 DOM 업데이트로 결합한 후 실제 DOM에 대한 업데이트를 일괄 처리
- DOM에 대한 효율적인 일괄업데이트를 계산하기위해 리액트는 현재 DOM 트리를 복제해 새로운 가상 DOM트리를 생성하고 업데이트 값을 적용함
- 재조정은 예상되는 다음 DOM상태와 현재 DOM을 일치시키는 과정,
- 리액트 16미만 버전에서 오래된 스택 재조정자를 사용한 방법을 소개 할 예정, 이를 바탕으로 파이버를 이해할 수 있을 것
- 스택 재조정자
    - 스택 기반 알고리듬을 사용해 새 가상트리를 이전 가상트리와 비교하고 DOM을 업데이트함
    - 간단한 경우에는 잘 작동했지만, 애플리케이션 규모가 커지고 복잡해지면서 여러 문제가 발생함
        - 계산비용이 비싼 컴포넌트가 렌더링을 막아버릴 수 있음
    - 스택 재조정자는 업데이트의 우선순위를 설정하지 않음. 따라서 덜 중요한 업데이트가 더 중요한 업데이트를 방해할 수 있었음
    - 업데이트가 추가된 순서대로 실행되었기 때문에, 더 중요한 업데이트를 차단할 수 있었음 → UI가 느리거나 끊기는 문제 발생
    - 스택 재조정자는 업데이트를 중단하거나 취소할 수 없음 ex) 예상치 못한 무작위 알림, 토스트 알림이 상호작용을 방해함
    - 끊김과, 사용자 인터페이스의 느린 응답 속도를 개선하기 위해 파이버 트리라는 파이버 재조정자를 개발했음
- 파이버 재조정자
    - 파이버는 상태를 저장하고 수명이 긴 반면, 리액트 엘리먼트는 임시적이고 상태가 없다는 점

정민

- 실제 DOM과 가상 DOM의 차이점, 리액트에서 가상 DOM을 사용할 때 이점
- 성능을 알아보는 것은 5장 memo, usememo
- dom을 실제로 적용하는 방법을 알아보고
    - reactDOM.createRoot(element).render() 동작을 배운다.
- DOM API의 호출을 어떻게 최소화 할까요?
    - 일괄처리에 대해 좀더 자세히 알아보자
- 문서 조각은 다수의 DOM 노드를 포함하는 가벼운 컨테이너로, 일종의 임시 스테이징 영역처럼 동작해서 문서의 실제 DOM에 영향을 주지 않고 여러 변경사항을 반영한다.
    - 최종적으로 문서조각을 DOM에 추가하면 단 한 번의 리플로와 리페인팅이 발생한다.
- count를 setcount로 3번 +1 하면 이걸 다음 동작을 확인해 한번에 +3을 한다.
- 재조정은 예상되는 다음 DOM의 상태와 현재 DOM을 일치시키는 과정
- 스택과 파이버 재조정
- 예전 리액트는 렌더링에 스택 데이터 구조를 사용했다.
- 스택 재조정자는 간단한 경우에는 잘 작동했지만, 애플리케이션 규모가 커지고 복잡해지면서 여러가지 문제가 발생했다.
    - 스택 재조정자는 작업을 시 중지 하거나 연기하지 않고 순차적으로 변경사항을 렌더링한다.
    - 계산 비용이 비싼 컴포넌트가 렌더링을 막아버리면 사용자 입력이 눈에 띄게 버벅거리며 화면에 표시된다.
        - 이로써 응답성은 나빠지고 사용자 경험은 엉망이 된다.
    - 사용자 입력처럼 우선순위가 높은 렌더링 작업이 끼어들 때는 진행중인 렌더링 작업을 멈출 수 있어야한다.
- 스택 재조정자는 업데이트의 우선순위를 설정하지 않았다.
- 주요한 문제점은 끊김 현상과 사용자 인터페이스의 느린 응답 속도 였다.
- 파이버 트리라는 데이터 구조를 기반으로 하는 신기술 파이버 재조정자를 개발했다.
- 파이버 재조정자
    - 조정자를 위한 작업 단위를 나타내는 파이버 구조가 사용된다.
    - 파이버는 상태를 저장하고 수명이 긴 반면 리액트 엘리먼트는 임시적이고 상태가 없다.

🥳 좋았던점 또는 알게된점(내용)

하은

- 리액트를 전문가처럼 쓰려면 리액트의 함수가 하는 일을 이해해야한다 라는 문장이 가치관과 맞는 내용이라 좋았음
- 아예 새로운 기술이아니라, 기존의 기술과 비슷한 맥락에서 더 발전된 기술이 발명된 것 같다는 생각이 들었다
- 리액트 16 미만버전에서의 문제점을 바탕으로 스토리텔링해줘서 이해가 잘 되는 것 같음
- 이전 버전에서는 스택 재조정자라는 방법을 이용했다는 점을 새로 알게 되었다
    - 계산비용이 큰, 비싼 컴포넌트가 렌더링을 막았음
- 결국 유저경험을 위해서 라이브러리가 발전해온 것

정민

- 예전 리액트는 렌더링에 스택 데이터 구조를 사용했다.
- 스택 재조정자는 간단한 경우에는 잘 작동했지만, 애플리케이션 규모가 커지고 복잡해지면서 여러가지 문제가 발생했다.
- 파이버 재조정자
    - 조정자를 위한 작업 단위를 나타내는 파이버 구조가 사용된다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- 

정민

- 주요한 문제점은 끊김 현상과 사용자 인터페이스의 느린 응답 속도였다.

👻 액션아이템 - 실천해볼만한 것

하은

- 리액트와 관련된 글을 하나 써야겠음

정민

- 스택 재조정자와 파이버 재조정자 차이 정리
- DOM API 호출의 일괄처리
- 스택 일 때 안좋았던 코드가, 파이버에서 좋은 것을 경험할 수 있는지 알아보기

👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  가상 돔 트리에서 props의 변화를 시각적으로 살펴볼 수 있는 교보재가 잇으면 찾아보기
- [ ]  리액트와 관련된 글을 하나 써야겠음
- [ ]  createDocumentFragment 살펴보기
- [ ]  offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기
- [ ]  합성 이벤트 시스템의 내부구현 살펴보기

정민

- [ ]  불필요한 렌더링 찾아보기
- [ ]  _owner, _store 확인해보기
- [ ]  react.createElement 및 document.element 차이점 확인
- [ ]  (가상, 일반) DOM API 호출의 일괄처리 차이
- [ ]  스택 일 때 안좋았던 코드가, 파이버에서 좋은 것을 경험할 수 있는지 알아보기