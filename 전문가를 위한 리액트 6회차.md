👻 액션아이템 - 실천해볼만한 것

하은

- [x]  가상 돔 트리에서 props의 변화를 시각적으로 살펴볼 수 있는 교보재가 잇으면 찾아보기
- [ ]  리액트와 관련된 글을 하나 써야겠음
- [ ]  createDocumentFragment 살펴보기
- [ ]  offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기
- [ ]  합성 이벤트 시스템의 내부구현 살펴보기

정민

- [ ]  불필요한 렌더링 찾아보기
- [x]  _owner, _store 확인해보기
- [x]  react.createElement 및 document.element 차이점 확인
- [x]  (가상, 일반) DOM API 호출의 일괄처리 차이
- [ ]  스택 일 때 안좋았던 코드가, 파이버에서 좋은 것을 경험할 수 있는지 알아보기
    - [ ]  바이브 코딩 해보거나 개발해보기

### 북스터디 진행 방식

1. 다음주에 이전주의 액션아이템을 실천했다면 경험을 공유해보기, 이야기 나눠보기
2. 문장 혹은 이야기하고 문단까지 읽어보기, 한 페이지씩 읽어보기 (챕터는 유동적으로)
    1. 한 사람 3페이지 읽고 1~2분 타이필 → 다시 읽기
    2. 3~5분 정도 회고 시간 가지기
3. 하은 → 정민 다 읽고 회고 하고 액션아이템 찾아보기

# Chapter 4.4 파이버 재조정자 (125p~132p)

하은

- 파이버는 데이터 구조, 리액트 엘리먼트에서 생성됨
- 파이버는 상태를 저장하고 수명이길지만, 리액트 엘리먼트는 상태가 없음
- [replay.io](http://replay.io) → 한번 살펴보기
- 파이버 재조정자는 업데이트 우선순위를 정하고 실행함
- 파이버 데이터 구조는 변경가능한 인스턴스로 설계되었으며, 필요에 따라 업데이트되고 재배치됨
- 파이버 각 인스턴스에는 프롭, 상태, 하위컴포넌트등이 포함됨
- 파이버 인스턴드에서 tag - 각 컴포넌트 유형(클래스 컴포넌트, 함수, 서스펜스, 및 오류 경게 조각)에 따라 고유한 숫자 ID가 파이버로 설정됨
- 조정 과정 중에 파이버 재조정자는 가상 DOM의 각 리액트 엘리먼트에대해 파이버 노드를 생성함
- 파이버 노드가 생성되면, 파이버 재조정자는 작업 루프를 사용해 사용자 인터페이스를 업데이트함
- 작업 루프는 파이버 노드에서 시작해, 컴포넌트 트리를 따라 내려가면서 업데이트가 필요한 파이버노드를 더티로 표시함
    - 끝에 도달하면 다시 반대로 순회하면서 새 DOM트리를 메모리에 생성
- beginWork → 위에서 아래로 이동하며 컴포넌트를 업데이트가 필요함으로 표시
- completeWork는 다시 위로 이동하며 브라우저에서 분리된 실제 DOM 엘리먼트의 트리를 메모리에 구성
- 오프스크린 렌더링 프로세스는 사용자가 볼 수 없으므로, 언제든지 중단하고 버릴 수 있음
- 다음 화면응ㄹ 화면 밖에서 준비한 다음 현재 화면으로 내보내는 더블 버퍼링이라는 게임 업계의 개념에서 착안함
- 더블 버퍼링은 컴퓨너 그래픽 및 비디오 처리에서 깜빡임을 줄이고 체감 성능을 개선하는 기술
    - 이미지나, 프레임을 저장하기 위한 두개의 버퍼블 생성하고, 일정 간격 동안 두 버퍼를 전환해 이미지나 동영상을 표시
    - 첫 버퍼가 표시되는 동안 두번째 버퍼가 새 데이터나 이미지로 업데이트되고, 두번째 버퍼가 준비되면 첫번째 버퍼로 전환되어 화면에 표시됨
    - 이를 이용하면, 이미지나 동영상이 중단이나 지연없이 표시되므로 시각적 잔상이 줄어듬
- 파이버 재조정은 더블 버퍼링과 비슷함, 업데이트가 발생하면 현재 파이버트리가 포크되어 사용자 인터페이스를 새 상태로 반영하도록 업데이트됨 → 렌더링
    - 현재 트리를 대체할 트리가 준비되면 현재 파이버 트리와 교체됨 → 커밋이라고 부름
    - 이점: 불필요한 업데이트를 피해서, 성능 개선 및 깜빡임을 줄임, 화면 밖에서 이 과정이 이루어짐
- 파이버 재조정
    - 렌더링과 커밋 두가지 단계로 이루어짐
    - 렌더링작업을 수행하고, 이를 DOM에 커밋해서 사용자에게 보여주기전 언제든 폐기할 수 있게되었음
    - 렌더링이 중단 가능한 것 처럼 보이는 이유는 5밀리초(120 프레임 정도)마다 실행을 메인 스레드로 돌려줘서
- 렌더링 단계
    - 현재 트리에서 상태 변경 이벤트가 발생하면 시작함, 재귀적 단계적으로 순회하고, 업데이트가 보류중이라는 신호플래그를 설정해 대체트리에 오프스크린 변경 작업을 수행함(beginWork에서 발생)
    - 작업용 트리에 있는 파이버 노드의 업데이트 필요 여뷰를 나타내는 플래그를 설정함
- beginWork
    - current: 현재 트리의 파이버 노드에 대한 참조, 업데이트 할지말지 결정하는데 사용함, 불변값
    - workInProgress: 업데이트중인 파이버 노드, 더티로 표시된 채 반환되는 노드
    - renderLanes: 업데이트가 처리되는 레인을 나타내는 비트마스크, 레인은 우선순위를 비롯한 여러 기준에 따라 업데이트를 분류하는 방식, 여러 특정에 따라 레인이 할당되고, 우선순위가 높을수록 더 높은 레인이 할당됨, 타임 슬라이싱이라는 기술을 사용해 실행 시간이 긴 업데이트를 더 작고 관리하기 쉬운 덩어리로 분할함, 렌더링이 완료되면, 렌더링 단계에 미뤄진 업데이트가 있는지 확인

정민

- 파이버 재조정자에는 조정자를 위한 작업단위를 나타내는 파이버라는 데이터 구조가 사용된다.
- 파이버는 3장에서 다룬 리액트 엘리먼트에서 생성된다.
    - 핵심적인 차이점은 파이버는 상태를 저장하고 수명이 긴 반면 엘리먼트는 임시적이고 상태가 없다.
- 마크 에릭슨 : 특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트의 내부 데이터 구조 라고 설명한다.
    - [replay.io](http://replay.io)  에서 시간 여행 디버깅을 확인할 수 있다.
- 이랙트 재조정에 파이버 트리를 사용한다. (마치 가상 DOM이 엘리먼트의 트리를 표현하는 것과 비슷하다.
- 파이버 재조정자는 업데이트의 우선순위를 정하고 이에 따라 동시 실행을 가능케 해서 리액트 애플리케이션의 성능과 응답성을 향상 시킨다.
    - tag
    - type
    - props
    - stateNode
- 파이버 트리를 비교해 어느 노드를 업데이트, 추가, 제거할지 파악하는 작업이 포함된다.
    - createFiberFromTypeAndProps 라는함수가 실행된다.
    - 작업 루프: 사용자 인터페이스를 업데이트
    - beginwork: 위에서 아래로 이동하며 컴포넌트를 업데이트 필요함으로 표시
    - completeWork: 다시 위로 이동하며 브라우저에서 분리된 실제 DOM 엘리먼트의 트리를 메모리에 구성한다.
        - 언제든지 중단가능
- 더블 버퍼링
    - 컴퓨터 그래픽 및 비디오 처리에서 깜빡임을 줄이고 체감 성능을 개선하는 기술이다.
- 이미지나 프레임을 저장하기 위한 두 개의 버퍼를 생성하고 일정한 간격으로 두 버퍼를 전환해 최종 이미지나 동영상을 표시한다.
- 더블 퍼버링 작동 방식
    1. 초기 이미지나 프레임으로 채우저ㅣㄴ다.
    2. 표시되는 동안 두번째 버퍼가 새 데이터나 이미지로 업데이트된다.
    3. 두 번째 버퍼가 준비되면 첫 번째 버퍼로 전환되어 화면에 표시된다.
    4. 첫 번째와 두 번째 버퍼가 일정한 간격으로 전환되어 최종 이미지나 동영상을 표시하는 프로세스가 계속된다. 
- 상태가 업데이트 될 때 렌더링이라고 한다.
- 재조정의 커밋 단계, 커밋 (교체 될 떄 재조정 명칭)
- 렌더링 단계는 현재 트리에서 상태 변경 이벤트가 발생하면 시작한다.
- 신호 플래그를 설정해 대체 트리에 “오프스크린” 변경 작업을 수행한다.
    - 리액트 내부적으로  beginwork라는 함수에 발생
- beginwork (시그니처 인수)
    - current
        - 업데이트 중인 작업용 노드에 해당하는 현재 트리의 파이버 노드에 대한 참조입니다.
        - 트리의 이전 버전과 새 버전 간에 변경된 사항과 업데이트할 사항을 결정하는데 사용된다.
        - (불변 값이며 비교용으로만 사용한다.)
    - workInPropgress
        - 작업용 트리에서 업데이트 중인 파이버 노드입니다. beginwork 함수에 의해 업데이트 되어 ‘더티’로 표시된 채 반환되는 노드입니다.
    - renderLanes
        - 렌더 레인은 리액트 파이버 재조정자에서 기존 renderExpirationTime을 대체하는 새로운 개념
        - 리액트가 업데이트 우선순위를 더 잘 정하고 업데이트 프로세스를 더 효율적으로 만들 수 있다.
            - renderExpirationTIme은 이제 사용되지 않는다.
        - 변경의 우선 순위가 높을수록 더 높은 레인이 할당 된다.
        - 업데이트가 올바른 순서로 처리되도록 하기 위해 renderLanes 값이 begin 함수에 전달된다.
            - 사용자 상호 작용이나 접근성에 영향을 미치는 업데이트 처럼 우선순위가 높은 업데이트가 최선적으로 처리된다.
        - 업데이트 우선순위를 지정하는 것 외에 다른 역할도 있다.
            - 리액트가 동시성을 더 잘 관리하도록 지원한다.
            - 타임 슬라이싱이라는 기술을 사용해 실행 시간이 긴 업데이트를 더 작고 관리하기 쉬운 덩어리로 분할한다.
                - 이 과정에서 renderLanes가 주된 역할로 업데이트의 우선순위를 정해줌
            - 렌더링 단계가 완료되면 getLanesToRetrySynchronouslyOnError함수가 호출되어 렌더링 단계 도중에 미뤄진 업데이트가 있는지 확인합니다.
                - 미뤄진 업데이트가 있는 경우 updateComponent 함수는 새로운 작업루프를 시작

🥳 좋았던점 또는 알게된점(내용)

하은

- 파이버 재조정자가 게임의 더블버퍼링이라는 기술에서 따왔다는 점이 흥미로움
- 이 재조정 과정은 오프스크린 렌더링 프로세스로, 유저가 알수없는 곳에서 발생한다는 점 → 화면 밖에서 새로운 UI 준비, 깜빡임 감소 및 인터랙션 차단 없음
- 렌더링, 커밋 그리고 레인의 우선순위에따라 처리되는 점이 흥미로움

정민

- 파이버의 동작과 어떠한 것에서 효과적인지 알 수 있었다.
    - 더블 버퍼링에 대한 이해
    - 실제 DOM에 대한 불필요한 업데이트를 피할 수 있다.
    - 화면 밖에서 UI의 새 상태를 계산하고 우선순위 조정
    - 재조정은 화면 밖에서 이루어지므로 사용자가 현재 보고 있는 내용을 망치지 않고 일시 중지했다가 다시시작 할 수 있다.
- 파이버 재조정자의 흐름에서 렌더링 단계 beginWork를 더 잘 알 수 있게 됐다.
- renderLanes라는 중요한 부분을 기억할 수 있게 됐고, renderExpirationTime을 쓰지 않는 것을 알게 됐다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- 

정민

- 

👻 액션아이템 - 실천해볼만한 것

하은

- [replay.io](http://replay.io) 를 살펴보기
- 더블 버퍼링과의 연관성에대해서 더 깊게 살펴보기

정민

- 파이버 재조정자에 대한 장점과 동작 원리 정리 → 블로그 또는 구현
- 회사 내에 리액트 16 미만인 버전이 있는지 찾아보기 (파이버 전 버전)

# Chapter 4 재조정 (132p~

하은

- completeWork
    - 작업용 파이버 노드에 업데이트를 적용 및 상태를 실제 DOM트리로 새롭게 생성함
    - 브라우저 환경이라면, document.createElement 또는 appendChild 함수를 호출할 것임
    - 리액트가 계산하는 다음상태가 아직 그려지지 않아서, 더 높은 업데이트가 발생하면 이 UI는 버려질 수 있음
    - 새 DOM트리를 구성하면, 렌더링 단계가 완료되었다고 볼 수 있음
- 커밋단계
    - 렌더링 단계에서 가상 DOM트리가 실제 DOM에 반영하는 것
    - 이 단계에서 효과도 모두 실행됨, 이 단계는 변형과 레이아웃 단계로 나뉨
- 변형단계
    - 가상 DOM에 적용된 사항을 실제 돔에 반영함, 이 단계에서 업데이트를 식별
    - commitUnmount, commitDeletion 같은 특수함수를 호출해, 더이상 필요하지 않는 노드를 제거하기도함
- 레이아웃 단계
    - 커밋 단계의 둘째 부분, DOM에서 업데이트된 노드의 새 레이아웃을 계산함
    - DOM에서 업데이트된 노드의 새 레이아웃을 계산함
    - 이 단계가 완료되면, 가상 DOM에 적용된 사항을 실제 DOM에 성공적으로 반영하게됨
- 커밋단계는 재조정자의 주요 기능들과 함께 동작해서 더 복잡해지고, 더 많은 데이터를 처리하더라도 앱이 빠르고 응답성이 뛰어나고 안정되도록 도와줌
- 효과
    - 재조정 과정의 커밋단계에서는 여러 부작용이 특정 순서로 실행되고, 그 순서는 효과 종류에 따라 달라질 수 있음
    - 커밋단계에서 발생하는 효과
        - 배치효과 → 새 컴포넌트가 DOM에 추가될 때 발생함
        - 업데이트효과 → 컴포넌트가 새로운 프롭이나 상태로 업데이트될 때 발생
        - 삭제효과 → 컴포넌트가 DOM에서 제거될 때 발생
        - 레이아웃 효과 → 브라우저의 페인트 가능 시점 전에 발생, useLayoutEffect
    - 커밋단계의 효과 달리 패시브 효과는 페인트 가능 시점 후에 실행되도록 예약된 사용자 정의 효과, useEffect
        - 초기 렌더링에 중요하지 않은 작업을 수행하는데 유용함
- 현재 트리나 작업용 트리 중 하나위에 FiberRootNode를 두고, 이는 커밋단계를 관리하는 핵심 데이터 구조
- 렌더링 프로세스가 완료되면, commitRoot를 통해 변경 사항을 실제 DOM에 커밋함
- 이 시점부터 모든 업데이트는 새로운 현재트리를 기반으로 이루어짐

정민

- completeWork (작업 완료)
- completeWork 함수는 작업용 파이버 노드에 업데이트를 적용하고 애플리케이션의 업데이트 된 상태를 나타내는 실제 DOM 트리를 새롭게 생성합니다.
    - 이 작업을 통해 DOM에서 분리된 트리를 브라우저가 시각적으로 표현하는 영역 바깥에 구성한다.
- 호스트 환경이 브라우저라면 document.createElement 똔s newEleements.appendChild 같은 작업을 수행한다.
- 리액트가 계사한 다음 상태는 아직 화면에 그려지지 않았으므로, 만약 우선순위가 더 높은 업데이트가 예약되면 여기서 만들어진 UI는 버려질 수 있다.
- completeWork 함수는 beginWork함수와 관계가 밀접하다.
- 커밋 단계
    - 렌더링 단계에서 가상 dOM에 적용된 변경 사항을 실제 돔에 반영한다.
    1. 변형 단계
        - 변형단계는 커밋 단계의 첫 부분으로 가상 DOM에 적용된 실제 DOM에 반영한다.
        - 리액트는 적용할 업데이트를 식별하고 commitMutatiionEffects라는 특수함수를 호출한다.
        - 변형 단계에서 리액트는 commitUnmount 및 commitDeletion 같은 특수 함수를 호출해 더 이상 필요하지 않은 노드를 DOM에서 제거한다.
    2. 레이아웃 단계
        - 커밋단계의 둘째 부분으로 DOM에서 ㄷ업데이트된 노드의 새 레이아웃을 계산한다.
        - 이 단계에서 commitLayoutEffects라는 특수 함수를 호출한다.
- 커밋 단계는 재조정자의 주요 기능들과 함계동작해서 더 복잡ㅇ해지고 더 많은 데이터를 처리하게 되는 상황에서도 리액트 애플리 케이션이 빠르고 응답성이 뛰어나며 안정되도록 도와준다.
- 효과
    - 리액트 재조정 과정의 커밋 단계에서는 여러 부작용이 특정 순서로 실행되며, 그 순서는 효과 종류에 따라 달라질 수 있다.
    - 배치효과
        - 
    - 업데이트효과
        - 
    - 삭제효과
        - 
    - 레이아웃 효과
        - 
- 커밋 단계의 효과와 달리 패시브 효과는 브라우저의 페인트 가능 시점 후에 실행되도록 예약된 사용자 정의 효과 이며 useEffect 훅을 사용해 관리됩니다.
- 패시브 효과는 API에서 데이터 요청이나 분석 주석처럼 페이지 초기 렌더링에 중요하지 않은 작업을 수행하는데 유용합니다.
    - 패시브 효과는 렌더링 단계에서 수행되지 않으므로 사용자 인터페이스 개발자가 원하는 상태로 만드는데 필요한 최소 업데이트 집합 계산 시간에 영향을 주지 않는다.
- 화면에 모두 표시하기
    - 리액트는 현재 트리나 작업용 트리 중 하나 위에 fiberRootNode를 둔다.
        - 재조정 과정에서 커밋 단계를 관리하는 핵심데이터 구조
    - 렌더링 프로세스가 완료되면 리액트는 commitRoot 함수를 호출해 작업용 트리에 적용된 변경 사항을실제 DOM에 커밋한다.
    - 향후 모든 업데이트는 새로운 현재 트리를 기반으로 이루어진다.
    - 이 과정을 통해 애플리케이션이 일관된 상태를 유지하고, 업데이트를 정확하고 효율적으로 적용할 수 있습니다.
    - 그리고 이 모든 작업은 즉시 브라우저에 반영됩니다.

🥳 좋았던점 또는 알게된점(내용)

하은

- 커밋 단계도 두 가지의 하위 단계로 나뉘어서 진행한다는점을 알게됨, 변형과 레이아웃
- 커밋 단계에서는 효과(Effect)가 특정 순서대로 이루어지고, 이 효과는 4가지종류가 있다
- 첫 트리가 만들어지면, 그 이후의 업데이트는 현재 트리 기반으로 이루어진다 SSOT,,?

정민

- 파이버의 렌더링 동작 중 completeWork 에 대한 동작을 알게 되었다.
- 커밋(4가지)에서 변형, 레이아웃 단계가 존재하고 각각 동작이 어떻게 되는지 알게되었다.
- 리액트의 안전성(일관성)과 빠른 응답성을 어떻게 유지하고 효율적으로 관리하는지 알게 되었다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- FiberRootNode는 항상 루트노드가 되는 것인지
- 조건부 렌더링에서, 배치 & 삭제가 이루어지는게 더 나을지(ex. isA ? <A/> : <B/>), 업데이트만 이루어지는게 더나을까? (<A isA={true or false} />)

정민

- 애플리케이션이 업데이트 되면 어떻게 된다..? 이건 잘 이해하지 못했다.

👻 액션아이템 - 실천해볼만한 것

하은

- 의문인 점들 더 살펴보기

정민

- 파이버에서의 동작을 그림으로 정리해보기
    - 각 동작에서 어떤게 일어나는지 mermaid로 적어도 괜찮을듯
- 4장 다시 읽어보기

👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  [꼭하기,,]createDocumentFragment 살펴보기
- [ ]  [꼭하기,,]offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기
- [ ]  [replay.io](http://replay.io) 를 살펴보기
- [ ]  더블 버퍼링과의 연관성에대해서 더 깊게 살펴보기
- [x]  FiberRootNode는 항상 루트노드가 되는 것인지
- [x]  조건부 렌더링에서, 배치 & 삭제가 이루어지는게 더 나을지(ex. isA ? <A/> : <B/>), 업데이트만 이루어지는게 더나을까? (<A isA={true or false} />)
    
    ## ✨ 커밋 단계에선 무엇이 중요한가?
    
    - **상태 유지가 중요하거나 애니메이션/포커스 등 continuity가 필요할 때는**
        
        → `<A isA={true or false} />` 형태가 더 적합
        
    - **서로 다른 책임을 가진 뷰를 명확히 구분하거나 side effect가 분리돼야 할 땐**
        
        → `isA ? <A /> : <B />`가 더 적절
        
        → mount/unmount를 명확히 발생시키는 게 오히려 클린한 경우도 있어
        

정민

- [ ]  [replay.io](http://replay.io) 살펴보기
- [ ]  파이버 재조정자에 대한 장점과 동작 원리 정리 → 블로그 또는 구현 (15v → 16v)
    - [ ]  더블 버퍼링
- [ ]  회사 내에 리액트 16 미만인 버전이 있는지 찾아보기 (파이버 전 버전)
- [ ]  파이버 동작을 mermaid같은 것으로 만들어보기 (시각화)
- [ ]  4장 다시 읽어보기