👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  언젠가,, JSX 파서를 만들어볼 수 있지 않을가..? 예전에 html 파서 실습했던 것 처럼,,,
- [ ]  어디가서 `<` 가 JSX의 프라그마라는 것을 아시나요? 라고 거들먹 거려보기
- [x]  아쉬운점에 있는 오탈자 제보 남기기.. ㅎㅎ → use strict

정민

- [ ]  2장 한번 더 읽기
- [x]  블로그 글정리
    - [ ]  코드는 어떻게 작동하는가?
        - 컴파일러
        - 런타임
        - 바벨
    - [ ]  JSX 장단점 및 목적 글 써보기
- [ ]  IOS의 SwiftUI가 만들게 되었을 떄 JSX의 영향 알아보기
- [x]  프라그마 종류 확인하기
- [ ]  프로그래밍 기초 (넛지 슬랙 찾아보기)

### 북스터디 진행 방식

1. 다음주에 이전주의 액션아이템을 실천했다면 경험을 공유해보기, 이야기 나눠보기
2. 문장 혹은 이야기하고 문단까지 읽어보기, 한 페이지씩 읽어보기 (챕터는 유동적으로)
    1. 한 사람 3페이지 읽고 1~2분 타이필 → 다시 읽기
    2. 3~5분 정도 회고 시간 가지기
3. 하은 → 정민 다 읽고 회고 하고 액션아이템 찾아보기

# Chapter 3 가상DOM (p87~p96)

하은

- DOM은 문서객체모델 → 실제 DOM은 노드객체이고 가상 DOM은 평범한 JS 객체
- 재조정: 가상DOM의 변경사항에 맞춰 실제 DOM을 업데이트하는 과정
- element의 offsetWidth를 읽기만 해도 reflow가 일어난다. → 성능상 비효율
- 트리의 각 노드는 HTML 엘리먼트이고, 조작 가능한 속성과 메서드를 포함함
- DOM을 직접 변경했을 때
    - querySelector 를 이용하면 CSS 선택자를 기반으로 찾지만, 복잡한 경우 속도이슈가 존재함 (전체 문서 트리에서 일치하는 엘리먼트를 찾음, 또한 선택자의 복잡도에 따라 탐색도 복잡해짐)
    - getElementById는 특정성이 높아서 더 효율적이긴 함 (O(1) 복잡도를 가짐) 그렇지만 웹 브라우저는 ID의 고유성을 강제하지 않아서, 충돌이 발생할 가능성이 높음
- 아이디는 고유해야해서 여러번 재사용되는 컴포넌트에는 적합하지 않음
- 클래스 이름이 동일한 여러 엘리먼트를 선택할 때에는 querySelector가 적절하지만, O(n) 복잡도를 가짐
- 로직을 컴포넌트화 할수 있다는 점, 변동성이 큰 환경에서 상태관리에 대한 걱정이 없다는 점에서 VDOM이 가지는 가치
- 실제 DOM을 다룰때 생길 수 있는 문제: 성능, 브라우저간 호환성, 보안취약성( XSS 취약점 )
- offsetWidth의 경우 상위 엘리먼트에 따라서 계산되는 속성이라 현재 레이아웃이 최신인지 확인해야해서 reflow등의 성능 문제가 발생할 수 있음 → getBoundingClientRect() 로 여러 레이아웃을 검색해 reflow 횟수를 줄일 수도 있긴함, 또는 읽기 및 쓰기 작업을 일괄처리하면 레이아웃 스레싱(레이아웃을 읽고, 쓰는작업이 반복될 때 발생하는 불필요한 계산)이 최소화됨
    - 콘솔로 이 작업을 확인하면 한번만 찍히긴하지만, 성능탭을 확인하면 offsetWidth를 계산하기 위한 백그라운드 작업에서 task를 확인하면 됨

정민

- VDOM 이라고 하는 가상 DOM의 개념과 리액트에서 가상 DOM이 중요한 이유
- 가상 DOM은 DOM과 마찬가지로 HTML 문서를 자바스크립트 객체로 모델링한 것
- 실제 DOM은 노드 객체로 구성되고 가상 DOM은 설명 역할을 하는 평범한 JS 객체로 구성된다.
- UI를 변경하라고 지시할 때 마다 가상 DOM을 먼저 업데이트 한 다음, 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트 한다. 이 과정을 **재조정이라고** 한다.
- 실제 DOM이 변경 될 때 마다 브라우저는 페이지 레이아웃을 다시 계산하고, 화면을 다시 그리며 시간이 오래 걸릴 수 있는 여러 작업을 수행한다.
- 브라우저가 문서의 전체나 일부 레이아웃을 다시 계산하는 과정을 거친다.
    - 이 과정을 리플로(reflow)라고 한다.
- querySelector를 사용해 실제 DOM에서 특정 노드를 검색하고 그 내용을 수정할 수 있다.
    - 다만 코드 전체를 위에서 부터 아래로 이동하면서 엘리먼트를 검색한다.
    - 여기서 getElementID를 실행하면 O(1)에 가깝다. (특정성이 높다.)
- 다만 여러번 재사용 되는 것은 querySelect가 더 적절하다.
    - 복잡도가 가변적이다.
- 리액트를 사용하면 가상 DOM을 통해 안전하게 DOM을 탐색할 수 있다.
- 실제 DOM에서 가장 문제 시 되는 사안은 성능이다.
- offsetWidth 속성에 접근하면 페이지에 있는 여러 엘리먼트의 레이아웃 위치를 다시 계산해야하는 리플로가 발생할 수 있다.
- getBoundingClientRect() 메서드를 사용해 레이아웃 읽기 및 쓰기를 일괄 처리하는 방법
    - 사용하면 한번의 호출로 여러 레이아웃 속성을 검색해 리플로의 발생 횟수가 준다.
    - 성능의 비결은 브라우저가 레이아웃을 강제로 다시 계산하는 횟수를 최소화한다.
    - 계산할 때는 한 번의 작업으로 필요한 정보를 모두 가져오도록한다.
        - 레이아웃 스래싱 현상이 최소화 된다.

🥳 좋았던점 또는 알게된점(내용)

하은

- element의 offsetWidth를 읽기만 해도 reflow가 일어난다는 점은 새로 알게되었음
- 실제 DOM을 다룰때 발생할 수 있는 문제점들을 짚어주는것부터 시작하는게 좋았던 것 같음
- 기존 함수로 레이아웃 스레싱을 줄이기위한 방법을 제시하는것 ㄱㅊ은 내용
- 확실히 다들 콘솔 한번만 찍히는데?로 소통하는 경우가 많은데 좋은 접근법을 알려준 것 같다

정민

- 가상 DOM은 DOM과 마찬가지로 HTML 문서를 자바스크립트 객체로 모델링한 것
- querySelector와 getElementId의 실행은 각각 어떻게 사용함에 따라 다르다. (가변적이다.)
- UI를 변경하라고 지시할 때 마다 가상 DOM을 먼저 업데이트 한 다음, 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트 한다.
- 레이아웃 스레싱이라는 말은 처음 들었다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- 

정민

- 실제 DOM에서 가장 문제 시 되는 사안은 성능이다.

👻 액션아이템 - 실천해볼만한 것

하은

- offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기

정민

- 빅오 표기법 확인
    - 프론트에서 사용할 떄
- getBoundingClientRect 사용 방법
- 레이아웃 스레싱

# Chapter 3 가상DOM(97p~105p)

하은

- 레이아웃의 속성값을 단순히 읽는것이라고 해도 완료까지 시간이 걸릴 수 있음
- 브라우저가 레이아웃 계산을 이미 수행한 경우라면 requestAnimationFrame을 통해 속성읽기를 잠시 멈출 수 있음
- 단순 li 엘리먼트를 생성하고 목록의 끝에 항목을 새로 추가해야할 때, 레이아웃을 다시 계산하고 페이지에 영향받는 부분을 다시 페인트해서 그리기 때문에 기기의 성능이나 요소갯수에 따라서 시간과 리소스가 소요될 것
- 가상DOM은 실제 DOM의 복잡성을 추상화하고 UI를 더 가볍게 표현함으로써 성능이 뛰어난 UI를 제작할 수 있음
- 요즘 시대에 사용자는 빠르고 응답성 좋은 웹을 기대함, 따라서 웹 개발자는 웹앱이 원활하고 CPU 효율성을 우선시 해야함, 그래서 몇 밀리초를 절약하는 것은 중요한 일임
- “밀리초가 수백만 달러를 만든다”
- reflow, repaint 를 발생시키는 직접적인 DOM 조작은 CPU 사용량과 처리시간을 증가시켜 사용자에게 지연 및 충돌을 일으킴
- 스마트폰, 태블릿같은 저전력기기 사용자에게 특히 더 심함 따라서 CPU 효율성을 우선시하면 메모리와 관계없이 다양한 기기의 사용자가 접근할 수 있는 앱 개발이 가능함
- 브라우저간 호환성 문제
- 브라우저마다 모델링 방식이 달라서 웹앱 일관성이 없고 버그가 발생할 수 있음
    - 지금은 좀 나아졌지만 여전히 어려운 상황
- 브라우저마다 특정 DOM 요소나 속성을 지원하지 않는 경우가 많아서, 이를 우회하는 방법을 구현하는데 많은 리소스가 들었음
- 리액트의 합성 이벤트 시스템은 이를 해결하고자 했다 (SyntheticEvent → 브라우저 기본 이벤트를 둘러싼 래퍼객체)
    - 통합 인터페이스를 제공함, 브라우저별 이벤트의 차이를 추상화해서 브라우저별 개별 코드를 작성하지 않아도 되게함
    - 이벤트 위임, 루트에서 이벤트를 위임받아서 일부 이벤트 사용불가한 상황을 막음
    - 기본 이벤트를 처리하는 방식을 개선했음 ex) onchange
    - SyntheticEvent 는 안정적인 이벤트 ㅣㅅ스템을 제공해서 네이티브 브라우저이벤트의 결점과 비일관성을 보완함
- **문서 조각**(document fragment) DOM 노드를 저장하는 가벼운 컨테이너, 업데이트 작업이 완료되면 문서조각을 DOM에 추가하는 방식으로 reflow, repaint를 한번만 발생시킴 (createDocumentFragment)
    - 일괄 업데이트: 실제 DOM을 개별로 업데이트하지않고 한번만 reflow, repaint를 실행함
    - 메모리 효율성: 문서 조각에 추가된 노드는 문서의 실제 DOM에서 제거됨, 재정렬할 때 메모리 사용량을 최적화함
    - 중복 렌더링 방지: 활성화된 DOM 트리에 속하지않아서, 이친구를 변경해도 실제 문서에는 영향을 주지 않음
- 웹앱에서 최적의 성능을 추구하는 개발자는 문서조각을 활용해서 더 부드러운 상호작용과 렌더링 시간 단축을 기대할 수 있음
- 리액트 가상DOM은 문서조각을 더 나은 방식으로 구현한것
    - 일괄 업데이트: 가상DOM은 여러 변경사항을 한번에 일괄처리함
    - 효율적인 비교알고리즘: 변경사항이 적용되고 나면 현재 가상 DOM과 실제 DOM의 차이점을 확인함
    - 단일 렌더링: 차이점이 식별되면 단 한번의 일괄 처리를 통해서 실제 DOM을 업데이트함
    - > 문서 조각과 관련한 복잡한 작업을 개발자가 신경쓰지 않아도되도록 내부적으로 처리함
- 가상 DOM 작동 방식
    - 메모리에 DOM의 가상표현을 만들고나면은 실제 DOM을 직접 수정하지 않고도 가상 표현을 변경할 수 있음
    - 실제 DOM 구현의 차이를 추상화한 일관된 API를 제공해서, web api가 다른 실행환경에서 다른 방식으로 동작해도 아무상관없이 JSX와 가상 DOM을 사용할 수 있음
- 리액트 엘리먼트는 (React.createElement) 로 생성됨
- 리액트 엘리먼트는 리액트 앱의 가장 작은 구성블록으로 화면에 표시되어야할 내용을 설명함
- 각 엘리먼트는 관련 프롭이나 속성과 함께 해당 엘리먼트가 나타내는 컴포넌트를 기술하는 평범한 자바스크립트 객체

정민

- 레이아웃 작업은 단순히 속상값을 읽는 것이라 해도 완료까지 약간의 시간이 걸립니다.
    - 브라우저가정확한 값을 반환하려면 레이아웃 정보가 최신 상태인지 확인해야하며, 이를 위해서는 문서 전체의 레이아웃을 계산해야 하기 때문입니다.
- 일반적으로 offsetWidth 같은 레이아웃 의존 속성을 읽을 때는 예기치 않은 선능 문제가 생길 수 있으므로 주의해야한다.
- 브라우저가 레이아웃 계산을 이미 수행한 경우라면 requestAnimationFrame APi를 사용해 다음 애니메이션 프레임까지 속성 읽기를 미룰 수 있습니다.
- 속도가 느린 기기에서 실행하거나 목록의 항목이 아주 많다면 상당한 시간과 리소스가 소요욀 것입니다.
- CSS 선택자 최적화, 이벤트 위임 사용, 읽기 쓰기 DOM 작업 일괄 처리, css 애미메이션 사용
- 밀리초가 수백만 달러를 만든다. → 구글
- 전 세계의 많은 사용자가 오래된 저성능 기기로 웹 애플리케이션에 접근한다면 문제는 더욱 복잡다단해진다.
- CPU 효율성을 우선시하면 처리 능력이나 메모리와 관계 없이 다양한 기기의 사용자가 접근할 수 있는 애플리케이션 개발이 가능하다.
    - 음.. 강제 업데이트를 하지 못하는 이유
- 실제 DOM에서 문제시되는 또 다른 사안은 브라우저 간 호환성이다.
- 브라우저마다 문서 모델링 방식이 달라 웹 애플리케이션이 일관성이 보장되지 않는다.
    - 음 지금은 크롬으로 많이 발전했다…
- 리액트의 합성 이벤트 시스템 - SyntheticEvent 브라우저의 기본 이벤트를 둘러싼 래퍼 객체
    - 브라우저의 일관성을 보장하기 위해 설계 되었다..!
- 리액트가 네이티브 이벤트를 SyntheticEvent 시스템으로 감싼 덕분에, 개발자는 네이티브 브라우저 이벤트 시스템의 비일관성과 괴상한 특성을 마주할 일이 없게 되었다..
    - 끔찍하네요. target || srcElement
- 브라우저간 호환성 (SyntheticEvent)
    - 통합 인터페이스
    - 이벤트 위임
    - 다양한 기능 개선
    - 네이티브 이벤트에 접근
- 문서 조각은 네이티브 객체지만, 리액트 가상 DOM의 전신이라고 볼 수 있다.
    - DOM을 직접 조작하는 작업은 특히 여러 변경 사항이 관련된 경우 성능이 많이 필요하다.
        - 레이아웃 재계산, UI 리페인팅, 화면 업데이트 등을 수행한다.
    - DOM 노드를 저장하는 가벼운 컨테이너 - 기본 DOM에 영향을 주지 않고 여러가지 업데이트를 수행할 수 있는 임시 저장소 처럼 동작한다.
- 문서 조각
    
    일괄 업데이트 
    
    메모리 효율성
    
    중복 렌더링 방지
    
- 포문을 돌려서 createDocumentFragment에 appendChild 에 항목을 추가하면
    - 실제 DOM 은 100번이 아니라 단 한 번 업데이트 된다.
- 이러한 방식으로 문서 조각은 여러 변경 사항을 일괄 처리해 DOM을 효율적으로 조작한다.
- 비용이 많이 드는 리플로와 리페인트 횟수가 줄게 된다.
    - 웹 애플리케이션 에서 최적의 성능을 추구하는 개발자는 문서 조각을 활용해 더 부드러운 상호 작용과 렌더링 시간 단축을 기대할 수 있다.
- 리액트의 가상 DOM은 업데이틀 처리해 렌더링의 효율성을 극대화한다.
- 리액트는 가상 DOM을 사용해 사용자 인터페이스를 구축합니다.
- 리액트 엘리먼트
    - 리액트에서 사용자 인터페이스는 컴포넌트 또는 HTML 엘리먼트의 가벼운 형태인 리액트 엘리먼트의 트리로 표현된다.
    - createElement를 사용해 생성 후 console.log로 실제로 생성된 엘리먼트를 볼 수 있다.
    - 

🥳 좋았던점 또는 알게된점(내용)

하은

- 밀리초가 수백만 달러를 만든다 라는 말에 완전 공감되는 듯
- reflow, repaint 가 발생하는 DOM 조작은 CPU 사용량을 증가시켜서 지연, 충돌이 발생할 수 있는 부작용을 갖고잇음
- 브라우저 호환성은 항상 겪는 문제인데, 리액트의 SyntheticEvent가 이를 통합했다는 것은 처음안 사실
- 문서 조각이라는 개념이 있는 것도 첨알앗슴..!
- 이를 바탕으로 VDOM이 구현되었다는 사실도..!
- 오늘도 겪은 사파리 이슈가 생각남,,

정민

- 브라우저가 정확한 값을 반환하려면 레이아웃 정보가 최신 상태인지 확인해야하며, 이를 위해서는 문서 전체의 레이아웃을 계산해야 하기 때문입니다.
- CSS 선택자 최적화, 이벤트 위임 사용, 읽기 쓰기 DOM 작업 일괄 처리, css 애미메이션 사용
- 리액트의 가상 DOM은 업데이트 처리해 렌더링의 효율성을 극대화한다.
- 브라우저간 호환성 (SyntheticEvent)
- 문서 조각

🥲 아쉬운점 또는 의문인점(내용)

하은

- 이번에도 없슴

정민

- 전 세계의 많은 사용자가 오래된 저성능 기기로 웹 애플리케이션에 접근한다면 문제는 더욱 복잡다단해진다.
- 브라우저마다 문서 모델링 방식이 달라 웹 애플리케이션이 일관성이 보장되지 않는다.

👻 액션아이템 - 실천해볼만한 것

하은

- createDocumentFragment 살펴보기
- 합성 이벤트 시스템의 내부구현 살펴보기

정민

- 문서 조각, 브라우저 호환성 찾아보기
- pollyfill과 syntheticEvent 다른점?
- 블로그
    - 문서 조각
    - 브라우저 호환성
    - SyntheticEvent

👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  createDocumentFragment 살펴보기
- [ ]  offsetWidth 이외에 속성을 읽는것만으로도 reflow가 발생할 수 있는 것들 찾아보기
- [ ]  합성 이벤트 시스템의 내부구현 살펴보기

정민

- [ ]  빅오 표기법 확인
    - 프론트에서 사용할 떄
- [ ]  문서 조각, 브라우저 호환성 찾아보기
- [ ]  getBoundingClientRect 사용 방법 찾아보기
- [ ]  레이아웃 스레싱 찾아보기
- [ ]  pollyfill과 syntheticEvent 다른점 찾아보기?