DATE: 2025. 7. 10.

👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  중첩 객체의 경우 memo가 어떻게 동작하는지 살펴보자
- [ ]  updateMemoComponent 함수를 더 살펴보고 이해해보기
- [ ]  관점을 달리해서 코드들을 바라보기

정민

- [ ]  memo는 얕은 비교를 한다는데, 깊은 비교를 하는 경우는 있는지 찾아보기
- [ ]  useMemo → memo의 동작 같은 걸지? (usememo, useCallback은 잘 사용하지 않는 부분으로 이해했었는데)
- [ ]  원시 타입 찾아보기
- [ ]  react.memo 에 대해서 코드 한번 더 살펴보기 (ai랑 같이해봐도 좋을듯)
- [ ]  배열을 메모리가 아닌 값으로 비교 (이 부분은 간단히 확인해보기)

### 북스터디 진행 방식

1. 다음주에 이전주의 액션아이템을 실천했다면 경험을 공유해보기, 이야기 나눠보기
2. 문장 혹은 이야기하고 문단까지 읽어보기, 한 페이지씩 읽어보기 (챕터는 유동적으로)
    1. 한 사람 3페이지 읽고 1~2분 타이핑 → 다시 읽기
    2. 3~5분 정도 회고 시간 가지기
3. 하은 → 정민 다 읽고 회고 하고 액션아이템 찾아보기

# Chapter 5 자주 묻는 질문과 유용한 패턴 (153p~)

하은

- updateMemoComponent 함수는 업데이트할지 최적화 할지 판단하는 역할
- 최초마운트에는 렌더링을 건너뛸 수 없음, 새 파이버를 생성하고 반환
- 프롭이 없는 단순 함수 컴포넌트인 경우 SImpleMemoComponent로 최적화하고, 얕은 비교만으로 업데이트 여부 결정
- 이전 렌더링이 있는 경우, 얕은 비교를 하고, ref가 동일한지 판단
- 예정된 리액트 컨텍스트 업데이트가 있는 경우 프롭이 바뀌지 않았더라도, 리렌더링함
- useMemo를 사용한 메모화
    - 정렬 작업은 애플리케이션을 느리게 만들 수 있음, 정렬 작업의 효율성은 항목수인 n에 의해 결정됨
    - useMemo 훅을 사용해 매번 배열을 정렬하지 않도록 함
- useMemo의 나쁜 사례
    - useMemo는 계산비용이 많이드는 연산, 객체, 배열에 대한 안정적인 참조를 유지하는데 유용함
    - 스칼라 값은 대체로 useMemo를 사용할 필요가 없음 → 실제 값으로 전달되고 비교되기 때문, 따라서 실제작업보다 비용이 더 들수도있다
    - 메모리 참조로 전달되는 onClick 핸들러를 렌더링 마다 다시 생성함 `onClick={()=> setCount()}`
    - 이 때 useCallback으로 메모해야한다고들하지만, 아님
    - 브라우저 네이티브 엘리먼트이고, 리액트 함수컴포넌트도 아니므로 메모해서 얻는 이점이 없음
    - 함수 프롭을 내장 컴포넌트에 전달하면, 리액트는 추가 작업 없이 실제 DOM엘리먼트에 직접 전달
    - 리액트는 이벤트 핸들러를 DOM에 직접추가하지 않고 이벤트 위임을 통해 이벤트를 처리함
        - 최상위 수준에 하나의 이벤트 리스너를 통해서 모든 이벤트를 수신하고 이벤트 버블링으로 각 컴포넌트의 이벤트를 포착
        - 메모리 사용량도 줄이고, 이벤트 핸들러 초기설정 시간을 단축해서 효율적임
        - 최상위 수준에서 동작이 이루어지지만, 이벤트 리스너가 직접 연결된 것 처럼 동작
    - 내장 컴포넌트는 함수 프롭의 변경에 의해서는 리렌더링되지 않음.
    - 인라인 함수를 전달하면 컴포넌트 렌더마다 새로운 함수가 되지만, 리액트는 변경 사항을 감지하기 위해 함수에대해 깊은 비교를 수행하지 않음. 단순히 새 함수는 DOM 엘리먼트에 설정된 기존 함수를 대체함 → 성능을 절약
    - 이벤트 핸들러에 이벤트 풀링을 사용해 메모리 부하를 줄임, 따라서 가비지 컬렉션 부하를 줄임
    - 내장 컴포넌트는 대부분의 경우 메모화로 이득없이 부하만 추가되기 떄문에, 이에대한 메모를 제공하지 않는다.
    - 사용자 정의 컴포넌트에 대해서만 메모를 진행함
    - 실질적으로는 리렌더링 비용이 많이드는 사용자 정의 컴포넌트에 새 함수 인스턴스를 전달할때는 주의가 필요하지만 내장 컴포넌트는 신경을 덜 써도됨
    - 그치만 불필요한 함수생성은 가비지 컬렉션을 자주 유발해서 성능문제로 이어질 수 있음

정민

- 최초 렌더링과 업데이트를 모두 처리하며, 새 파이버를 생성해야 하는지 아니면 기존 파이버를 업데이트 해야하는지에 따라 다른 작업을 수행한다.
- react.memo 컴포넌트가 리렌더링 되는 조건과 그렇지 않은 조건에 대해 알아봅시다.
    - 이전 렌더링 없음 (최초 마운트)
        - current === null 인 경우 컴포넌트가 처음 마운트 되는 것이므로 렌더링을 건너뛸 수 없습니다.
        - 컴포넌트가 렌더링할 새 파이버가 생성되고 반환된다.
    - 단순 함수 컴포넌트 최적화
    - 비교 함수
    - 개발 모드에서 기본 프롭과 프롭타입
    - 빠른 종료 조건
    - 수행된 작업 플래그
- react.memo 컴포넌트는 콘텍스트 변경에 의해 업데이트가 없고 기존 프롭과 새 프롭을 비교한 결과 두 프롭이 동일하면 다시 렌더링되지 않습니다.
    - 프롭을 비교할 때는 기본값으로 제공되는 얕은 비교 함수 또는 사용자가 제공하는 비교함수를 사용한다.
    - 두 프롭이 다르거나 상태나 콘텍스트 변경이 있다면 컴포넌트가 다시 렌더링 됩니다.
- react.memo와 usememo훅은 모두 메모화를 위한 도구지만 용도가 매우 다르다.
    - react.memo는 전체 컴포넌트를 메모화해 렌더링이 다시 발생하지 않게 합니다.
    - useMemo는 컴포넌트 내부의 특정 계산을 메모화해 비용이 많이 드는 재계산을 피하고 결과에 대한 일관된 참조를 유지합니다.
- 정렬 작업의 시간 복잡도는 평균 및 최악의 시나리오에서 일반적으로 O(n log n)입니다.
    - 백만명이 포함되었다면 렌더링할 때 마다 계산에 상당한 과부하가 발생할 수 있다.
- useMemo는 계산 비용이 많이 드는 연산을 메모화하거나 객체와 배열에 대한 안정적인 참조를 유지하는데 특히 유용합니다.
- **문자열, 숫자, 불리언 같은 스칼라 값은 대체로 useMemo를 사용할 필요가 없습니다.**
- 스칼라값은 자바스크립트에서 참조가 아닌 실제값으로 전달되고 비교된다.
- 내장 컴포넌트에서 함수 프롭을 사용하면 다음과 같은 일이 발생한다.
    - 직접 전달
        - 리액트 애플리케이션을 작성할 때 이러한 이벤트 위임 시스템을 전혀 고려할 필요가 없다.
    - 렌더링 동작
        - 대체로 프로파일링등을 통해 성능에 문제가 된다고 판명되지 않는 한 최적화할 필요가 없습니다.
    - 함수에 대한 가상 DOM 비교하지 않음
        - 내장 컴포넌트에 대한 가상 DOM 비교는 함수 프롭의 동일성을 기반으로 합니다.
        - 인라인 함수를 전달하면 컴포넌트가 렌더링 될 때 마다 새로운 함수가 되지만, 리액트는 변경 사항을 감지하기 위해 함수에 대해 깊은 비교를 수행하지 않습니다.
        - 단순히 새 함수는 DOM 엘리먼트에 설정된 기존 함수를 대체하게 되며, 덕분에 내장 컴포넌트에서 성능을 절약하게 된다.
    - 이벤트 풀링
        - 이벤트 핸들러에 전달되는 이벤트 객체는 풀링된 합성 이벤트인데 여러 이벤트 핸들러에 재사용됨으로써 가비지 컬렉션 부하를 줄입니다.
- 내장 컴포넌트 함수 프롭의 성격은 사용자 정의 컴포넌트와 매우 대조적입니다.
- 내장 컴포넌트라면 대부분의 경우 메모화로 이득 없이 부하만 추가가 되기 때문에 리액트는 내장 메모화를 제공하지 않습니다.
    - 리액트가 출력하는 실제 DOM요소에는 메모화 개념이 없습니다.
- 함수를 새로 생성하고 전달하는 것에 대해서는 항상 주의하는 편이 좋습니다.
    - 불필요한 함수 생성은 가비지 컬렉션을 자주 유발하며, 업데이트가 매우 잦은 경우에는 성능 문제로도 이어질 수 있습니다.
- 

🥳 좋았던점 또는 알게된점(내용)

하은

- useMemo의 경우에는 연산, 객체, 배열에 대해서 안정적인 참조를 유지하는데 유용하다는 점을 알았음
- 스칼라 값은 메모하지 않아도 된다는점을 알았음
- 이벤트 핸들러를 직접 넣는게 아니라 최상위에서 이벤트 리스너를 수신한다는 점도 신기
- 인라인함수를 전달하는 것은 매 렌더마다 생성하긴하지만, 내장 컴포넌트의 경우에는 크게 신경쓰지 않아도 괜찮다는 점

정민

- react.memo 컴포넌트가 리렌더링 되는 조건과 그렇지 않은 조건을 알게 되었다.
- react.memo와 usememo훅은 모두 메모화를 위한 도구지만 용도가 매우 다르다.
- **문자열, 숫자, 불리언 같은 스칼라 값은 대체로 useMemo를 사용할 필요가 없습니다.**
- 스칼라값은 자바스크립트에서 참조가 아닌 실제값으로 전달되고 비교된다.
- 내장 컴포넌트에서 함수 프롭을 사용하면 발생하는 일도 잘 알게 되었다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- useMemo의 의존성 배열에는 객체나, 배열등이 들어갈 것 같은데 이거는 얕은 비교를 하지 않는건가 싶기도하고?

정민

- 이 책을 조금만 더 일찍 봤으면 memo, useMemo를 사용을 꽤 했을 것 같다.
    - out of memory
- 나는 잘 사용하지 않아서 여태 잘 하고 있었는지 의문이다.

👻 액션아이템 - 실천해볼만한 것

하은

- memo, useMemo 의존성 배열의 비교 연산 차이 살펴보기

정민

- react.memo 컴포넌트가 리렌더링 되는 조건과 그렇지 않은 조건 좀 더 살펴보기
- react.memo ↔ useMemo 비교하기
    - 예제도 만들어보기
- 시간 복잡도 확인해보기 → sort와 같은 것들

# Chapter 5. 자주 묻는 질문과 유용한 패턴(160p~)

하은

- useCallback을 가져와서, 호출하고, 의존성을 전달하고, 의존성을 비교해 함수계산이 필요한지 확인해야해서 불필요한 부하가 추가 될 수 있음
- 자주 리렌더링 할 가능성이 있는 컴포넌트가 있고, 하위 컴포넌트에 콜백을 전달할 때, 하위컴포넌트가 memo 등으로 최적화된경우에 useCallback은 유용함
    - 콜백을 메모화하면 부모 컴포넌트를 렌더링할 때 자식컴포넌트가 불필요하게 다시 렌더링하지 않기 때문
    - 자식 컴포넌트 렌더링의 비용이 비싸서 렌더링 횟수를 줄여 성능을 최적화하려는 경우에 유용함
- 컴포넌트가 무상태 컴포넌트라면, useMemo를 사용하지 않아도됨
- 변수의 값이 스칼라 값이라면, 계산하는 동안 함수를 매번 호출하긴해도 자바스크립트 엔진과 리액트 런타임이 성능 부분을 도맡아 줄 수 있을것
    - 정렬, 필터, 매핑처럼 추가 계산이 필요없는 단순한 할당
    - 그래서, useMemo를 가져오고, 호출하고, 의존성을 전달하고, 다음 의존성을 비교해 값을 다시 계산해야하는지 확인하는 등 useMemo자체의 부하에의해 애플리케이션 속도가 오히려 느려질 수 있음
    - 이런 동작들이 성능에 도움되지 않고, 오히려 해가될 수 있는 런타임 복잡성을 초래함 → 그래서 메모리 릭이 나나보다,,
- 모두 잊고 포겟하세요..
    - 리액트 컴파일러는 리액트 앱에서 메모화를 자동화하기 위한 새로운 도구
    - 리액트 컴파일러는 리액트 리렌더링 동작의 객체 동일성 비교를 깊은 비교 없는 시멘팅 값 비교로 변환해 성능을 향상 시킨다.
- 지연 로딩
    - 앱 규모가 커지면, 자바스크립트 코드양도 증가함 → 초기 로딩도 느리고, 캐시에 필요한 헤더를 추가할수 없는 상황에서는 다른 페이지 접속마다 번들을 다시 다운로드해야함
    - 인터넷 속도가 느리거나, 구형디바이스에서는 페이지로딩이 더 오래 걸릴 수 있음
    - async를 이용해서, 자바스크립트 파일을 비동기적으로 읽어 들여서 페이지 로딩을 조금 개선할 수도 있음
    - 자바스크립트를 너무 많이 전송하면 데이터 사용량이 증가함 → 데이터가 제한적인 요금제라면 사용자의 부담은 커짐..
    - 코드스플릿팅을 사용하면, 특정 페이지나 기능에 필요한 자바스크립트만 읽을 수 있음 → 이걸로 문제를 일부 해결할 수 있다
    - 또 다른 방법으로는, 지연 로딩을 사용해서 페이지를 완전 읽어 들일때까지 초기 실행에 필요하지 않는 자바스크립트 로딩을 미룰수있음

정민

- 따라서 useCallback은 크게 도움이 되지 않으며, 사실 쓸모 없을 뿐만 아니라 애플ㅋ리케이션에 불필요한 부하만 추가한다.
- useCallback을 가져와서 호출하고 의존성을 전달한 다음 의존성을 비교해 함수를 다시 계산해야 하는지 확인해야한다.
    - 이 모든 과정은 성능에 이롭기보다 오히려 해로운 런타임 복잡성을 초래합니다.
- useCallback은 자주 리렌더링 할 가능성이 있는 컴포넌트가 있고 하위 컴포넌트에 콜백을 전달할 때, 특히 하위 컴포넌트가 React.memo 또는 shouldComponentUpdate로 최적화된 경우 매우 유용하다.
    - 콜백을 메모화 하면 부모 컴포넌트를 렌더링할 때 자식 컴포넌트가 불필요하게 다시 렌더링하지 않는다.
- 자식 컴포넌트 렌더링의 비용이 비싸서 렌더링 횟수를 줄여 성능을 최적화하려는 경우에 유용하다.
- useMemo자체의 부하에 의해 애플리케이션 속도가 오히려 느려질 가능성이 높으로 useMemo를 사용하지 않을 때가 있다.
- 리액트가 필요한 경우에 컴포넌트를 자체적으로 최적화해 줄 것을 믿고 메모화 대신 할당만 해도 된다.
- 리액트 컴파일러
    - 리액트 컴파일러는 리액트 애플리케이션에서 메모화를 자동화하기 위한 새로운 도구로 useMemo, useCallback 같은 훅을 쓸모 없게 만들 수 있습니다.
    - 리액트 컴파일러는 사용자 경험(UX)와 개발자 경험(DX)를 모두 개선합니다.
    - 2021년에 페이스북, 인스타그램 메타의 제품에 사용되어 내부적으로 기대 이상의 성과를 거두고 있다.
- 지연 로딩
    - 애플리케이션 규모가 커지면서 자바스크립트 코드의 양도 증가한다.
    - 어떤 때는 코드의 일부만 사용할 건데 두자릿 수 메가바이트급의 방대한 자바스크립트 번들을 다운로드 해야합니다.
    - 그러면 사용자의 초기 로딩이 더딘데다, 번들을 제공하는 서버에 접근할 수 없거나 캐시에 필요한 헤더를 추가할 수없는 상황에서는 다른 페이지에 접속할 때 마다 번들을 다시 다운로드 해야한다.
        - 자바스크립트를 너무 많이 전송하면 페이지 로딩 시간이 느려질 수 있다.
        - 자바스크립트 파일은 일반적으로 HTML, CSS 같은 종류의 웹파일보다 크기가 크고 실행하려면 더 많은 처리 시간이 필요하다.
    - script에서 async 속성을 사용해 자바스크립트 파일을 비동기적으로 읽어들이면 대체로 해결된다.
- 코드 분할을 사용해특정 페이지나 기능에 필요한 자바스크립트만 읽어들이는 방법
    - 필요한 코드만 읽어 들여서 페이지 로딩 시간과 데이터 사용량을 줄인다.
- import → then으로 비동기적으로 특정 파일에서 필요한 코드만 읽어 들이므로 ㅍ페이지 로드 시간과 데이터 사용량을 줄일 수 있다.

🥳 좋았던점 또는 알게된점(내용)

하은

- 자주 리렌더링 할 가능성이 있는 컴포넌트가 있고, 하위 컴포넌트에 콜백을 전달할 때, 하위컴포넌트가 memo 등으로 최적화된경우에 useCallback은 유용함
- 자식 컴포넌트 렌더링의 비용이 비싸서 렌더링 횟수를 줄여 성능을 최적화하려는 경우에 유용함
- 컴포넌트에 상태가 없다면, 메모하지 않아도 괜찮음
- 계산된 변수의 값이 스칼라여서 단순 할당만한다면, 굳이 메모하지 않아도됨 → 오히려 useMemo로 인해서 메모리 릭이 발생할 수도 있음
- 리액트 컴파일러는 시멘틱 값 비교로 변환해 성능을 챙겼음
- 코드 스플리팅 또는 지연로딩을 통해서 페이지 로드시간과 데이터 사용량을 줄일 수 있다

정민

- useCallback은 자주 리렌더링 할 가능성이 있는 컴포넌트가 있고 하위 컴포넌트에 콜백을 전달할 때 → memo, shouldUpdate 된경우 유용
    - 자식 컴포넌트 렌더링의 비용이 비싸서 렌더링 횟수를 줄여 성능을 최적화하려는 경우에 유용하다.
- 리액트가 필요한 경우에 컴포넌트를 자체적으로 최적화해 줄 것을 믿고 메모화 대신 할당만 해도 된다.
- 리액트 컴파일러는 리액트 애플리케이션에서 메모화를 자동화하기 위한 새로운 도구로 useMemo, useCallback 같은 훅을 쓸모 없게 만들 수 있습니다.
- 지연로딩, 코드 스플리팅에 대해서 좀 더 생각해보게 된다.

🥲 아쉬운점 또는 의문인점(내용)

하은

- 

정민

- 리액트가 필요한 경우에 컴포넌트를 자체적으로 최적화해 줄 것을 믿고 메모화 대신 할당만 해도 된다. (뭐에요… 갈팡질팡)
- 지연 로딩과 코드 분할 많이 사용하나요..?
    - 자주는 못 보았고, 잘 사용하지 않았었습니다…!
    - 모듈 최적화 시엔 조금 사용해보았어요.
        - 다만 import에 import가 많아서 병합은 못했어요… (사이드 이펙트..!)
    

👻 액션아이템 - 실천해볼만한 것

하은

- 회사 코드들에서 사용되는 useCallback과 useMemo의 의존성배열을 조금 점검해보자
- 메모할지말지 기준을 정량적으로 잡아보는 것
- 리액트 컴파일러의 시멘틱 값비교를 좀 더 살펴봐도 좋을 듯

정민

- useMemo, useCallback에 잘 사용하는 것, 잘 못 사용하고 있는 코드들을 게임화 시켜도 좋을 것 같다. → 만들어보기 (AI)
- 리액트 컴파일러를 한번 사용해보는 것도 좋을 것 같다.
    - https://ko.react.dev/learn/react-compiler
    - 한번 읽어보기
    - 

https://react.dev/learn/react-compiler

👻 액션아이템 - 실천해볼만한 것

하은

- [ ]  중첩 객체의 경우 memo가 어떻게 동작하는지 살펴보자
- [ ]  memo, useMemo 의존성 배열의 비교 연산 차이 살펴보기
- [ ]  회사 코드들에서 사용되는 useCallback과 useMemo의 의존성배열을 조금 점검해보자
- [ ]  메모할지말지 기준을 정량적으로 잡아보는 것
- [ ]  리액트 컴파일러의 시멘틱 값 비교를 좀 더 살펴봐도 좋을 듯

정민

- [ ]  useMemo, useCallback에 잘 사용하는 것, 잘 못 사용하고 있는 코드들을 게임화 시켜도 좋을 것 같다. → 만들어보기 (AI)
- [ ]  리액트 컴파일러를 한번 사용해보는 것도 좋을 것 같다.
    - https://ko.react.dev/learn/react-compiler
    - 한번 읽어보기
- [ ]  react.memo 컴포넌트가 리렌더링 되는 조건과 그렇지 않은 조건 좀 더 살펴보기
- [ ]  시간 복잡도 확인해보기 → sort와 같은 것들
- [ ]  memo는 얕은 비교를 한다는데, 깊은 비교를 하는 경우는 있는지 찾아보기
- [x]  useMemo → memo의 동작 같은 걸지? (usememo, useCallback은 잘 사용하지 않는 부분으로 이해했었는데)
- [ ]  원시 타입 찾아보기
- [ ]  react.memo 에 대해서 코드 한번 더 살펴보기 (ai랑 같이해봐도 좋을듯)
- [ ]  배열을 메모리가 아닌 값으로 비교 (이 부분은 간단히 확인해보기)